<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[超详细的node垃圾回收机制]]></title>
    <url>%2Farchives%2Fundefined.html</url>
    <content type="text"><![CDATA[前言垃圾回收器是一把十足的双刃剑。其好处是可以大幅简化程序的内存管理代码，因为内存管理无需程序员来操作，由此也减少了（但没有根除）长时间运转的程序的内存泄漏。对于某些程序员来说，它甚至能够提升代码的性能。 另一方面，选择垃圾回收器也就意味着程序当中无法完全掌控内存，而这正是移动终端开发的症结。对于JavaScript，程序中没有任何内存管理的可能——ECMAScript标准中没有暴露任何垃圾回收器的接口。网页应用既没有办法管理内存，也没办法给垃圾回收器进行提示。 nodeJs查看垃圾回收日志的方式主要是在启动时添加 --trace_gc 参数。 关于垃圾回收垃圾回收器要解决的最基本问题就是，辨别需要回收的内存。一旦辨别完毕，这些内存区域即可在未来的分配中重用，或者是返还给操作系统。一个对象当它不是处于活跃状态的时候它就死了（废话）。一个对象处于活跃状态，当且仅当它被一个根对象或另一个活跃对象指向。根对象被定义为处于活跃状态，是浏览器或V8所引用的对象。比如说，被局部变量所指向的对象属于根对象，因为它们的栈被视为根对象；全局对象属于根对象，因为它们始终可被访问；浏览器对象，如DOM元素，也属于根对象，尽管在某些场合下它们只是弱引用。 从侧面来说，上面的定义非常宽松。实际上我们可以说，当一个对象可被程序引用时，它就是活跃的。比如：12345function f() &#123; var obj = &#123;x: 12&#125; g() // 可能包含一个死循环 return obj.x&#125; 这里的obj.x和obj都是活跃的，尽管对其的再度引用是在死循环之后。 很遗憾，我们无法精确地解决这个问题，因为这个问题实际等价于停机问题，无法确定。因此我们做一个等价约定：如果一个对象可经由某个被定义为活跃对象的对象，通过某个指针链所访问，则它就是活跃的。其他的都被视为垃圾。 垃圾回收过程 垃圾回收机制有多种，但最常用的就是以下几种： 分代回收在V8中所有的JavaScript对象都是通过堆来分配的。为了提高垃圾回收的效率，V8将堆分为新生代和老生代两个部分，其中新生代为存活时间较短的对象(需要经常进行垃圾回收)，而老生代为存活时间较长的对象(垃圾回收的频率较低)，如图 新生代新生代中的对象主要通过 Scavenge 算法进行垃圾回收。在 Scavenge 的具体实现中，主要采用了 Cheney 算法。 Cheney 算法是一种采用复制的方式实现的垃圾回收算法。它将堆内存一分为二，每一部分空间成为 semispace。在这两个 semispace 空间中，只有一个处于使用中，另一个处于闲置中。处于使用中的 semispace 空间成为 From 空间，处于闲置状态的空间成为 To 空间。当我们分配对象时，先是在 From 空间中进行分配。当开始进行垃圾回收时，会检查 From 空间中的存活对象，这些存活对象将被复制到 To 空间中，而非存活对象占用的空间将被释放。完成复制后， From 空间和 To 空间的角色发生对换。 Scavenge 的缺点是只能使用堆内存的一半，但 Scavenge 由于只复制存活的对象，并且对于生命周期短的场景存活对象只占少部分，所以它在时间效率上表现优异。Scavenge 是典型的牺牲空间换取时间的算法，无法大规模地应用到所有的垃圾回收中，但非常适合应用在新生代中。 对象是如何释放的呢？ 有个叫可达性分析算法的概念，即通过一系列的称为“GC ROOT”的对象作为起始点。从这些节点开始向下搜索。搜索走过的路径称为引用链。当一个对象到GC ROOT没有任何引用链时，则证明此对象是不可用的。当然在虚拟机判断要被释放的对象里面，即使在可达性分析算法中不可达的对象，也并非是立即释放的。如果对象在进行可达性分析后发现没有与GC ROOTS相连接的引用链。将会对它进行一次标记，并进行刷选。它会放进一个队列中依次进行回收。如果这时又有对象引用到它，它就不会被回收。 晋升 对象从新生代中移动到老生代中的过程称为晋升。 From 空间中的存活对象在复制到 To 空间之前需要进行检查，在一定条件下，需要将存活周期长的对象移动到老生代中，也就是完成对象的晋升。 晋升条件主要有两个： 对象是否经历过一次 Scavenge 回收，是的话，则移动到老生代 To 空间已经使用超过 25%，To 空间对象移动到老生代 设置 25% 这个限制值得原因是当这次 Scavenge 回收完成后，这个 To 空间将变成 From 空间，接下来的内存分配将在这个空间中进行，如果占比过高，会影响后续的内存分配。 写屏障上面有一个细节被忽略了：如果新生区中某个对象，只有一个指向它的指针，而这个指针恰好是在老生区的对象当中，我们如何才能知道新生区中那个对象是活跃的呢？显然我们并不希望将老生区再遍历一次，因为老生区中的对象很多，这样做一次消耗太大。 为了解决这个问题，实际上在写缓冲区中有一个列表(我们称之为CrossRefList)，列表中记录了所有老生区对象指向新生区的情况。新对象诞生的时候，并不会有指向它的指针，而当有老生区中的对象出现指向新生区对象的指针时，我们便记录下来这样的跨区指向。由于这种记录行为总是发生在写操作时，它被称为写屏障——因为每个写操作都要经历这样一关。 老生代老生代的内存空间较大且存活对象较多，因此其垃圾回收算法也就没有新生代那么简单了。为此V8使用了标记-清除算法 (Mark-Sweep)进行垃圾回收，并使用标记-压缩算法 (Mark-Compact)整理内存碎片，提高内存的利用率。老生代的垃圾回收算法步骤如下：12341. 对老生代进行第一遍扫描，标记存活的对象2. 对老生代进行第二次扫描，清除未被标记的对象3. 将存活对象往内存的一端移动4. 清除掉存活对象边界外的内存 Mark-SweepMark-Sweep 是标记清除的意思，它分为两个阶段，标记和清理。Mark-Sweep 在标记阶段遍历堆中的所有对象，并标记活着的对象，在随后的清除阶段中，只清除未被标记的对象。 算法机制 在标记阶段，所有堆上的活跃对象都会被标记。每个页（注意，V8的内存页是1MB的连续内存块，与虚拟内存页不同）都会包含一个用来标记的位图，位图中的每一位对应页中的一字。这个标记非常有必要，因为指针可能会在任何字对齐的地方出现。显然，这样的位图要占据一定的空间（32位系统上占据3.1%，64位系统上占据1.6%），但所有的内存管理机制都需要这样占用，因此这种做法并不过分。除此之外，另有2位来表示标记对象的状态。由于对象至少有2字长，因此这些位不会重叠。 状态一共有三种：如果一个对象的状态为白，那么它尚未被垃圾回收器发现；如果一个对象的状态为灰，那么它已被垃圾回收器发现，但它的邻接对象仍未全部处理完毕；如果一个对象的状态为黑，则它不仅被垃圾回收器发现，而且其所有邻接对象也都处理完毕。 如果将堆中的对象看作由指针相互联系的有向图，标记算法的核心实际是深度优先搜索。在标记的初期，位图是空的，所有对象也都是白的。从根可达的对象会被染色为灰色，并被放入标记用的一个单独分配的双端队列。标记阶段的每次循环，GC会将一个对象从双端队列中取出，染色为黑，然后将它的邻接对象染色为灰，并把邻接对象放入双端队列。这一过程在双端队列为空且所有对象都变黑时结束。 特别大的对象，如长数组，可能会在处理时分片，以防溢出双端队列。如果双端队列溢出了，则对象仍然会被染为灰色，但不会再被放入队列（这样他们的邻接对象就没有机会再染色了）。因此当双端队列为空时，GC仍然需要扫描一次，确保所有的灰对象都成为了黑对象。对于未被染黑的灰对象，GC会将其再次放入队列，再度处理。 标记算法结束时，所有的活跃对象都被染为了黑色，而所有的死对象则仍是白的。这一结果正是清理和紧缩两个阶段所期望的。 类似三色标记法大致如图： 第一步 第二步 第三步 清理阶段,清理算法扫描连续存放的死对象，将其变为空闲空间，并将其添加到空闲内存链表中。每一页都包含数个空闲内存链表，其分别代表小内存区（&lt;256字）、中内存区（&lt;2048字）、大内存区（&lt;16384字）和超大内存区（其它更大的内存）。 清理算法非常简单，只需遍历页的位图，搜索连续的白对象。空闲内存链表大量被scavenge算法用于分配存活下来的活跃对象，但也被紧缩算法用于移动对象。有些类型的对象只能被分配在老生区，因此空闲内存链表也被它们使用。 Mark-CompactMark-Sweep 最大的问题是在进行一次标记清除回收后，内存空间会出现不连续的状态。这种内存碎片会对后续的内存分配造成问题，因为很可能出现需要分配一个大对象的情况，这时所有的碎片空间都无法完成此次分配，就会提前触发垃圾回收，而这次回收是不必要的。 为了解决 Mark-Sweep 的内存碎片问题，Mark-Compact被提出来。Mark-Compact是标记整理的意思，是在 Mark-Sweep的基础上演进而来的。它们的差别在于对象在标记为死亡后，在整理过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。 算法机制 紧缩算法会尝试将对象从碎片页（包含大量小空闲内存的页）中迁移整合在一起，来释放内存。这些对象会被迁移到另外的页上，因此也可能会新分配一些页。而迁出后的碎片页就可以返还给操作系统了。 迁移整合的过程非常复杂，大概过程是这样的。对目标碎片页中的每个活跃对象，在空闲内存链表中分配一块其它页的区域，将该对象复制至新页，并在碎片页中的该对象上写上转发地址。迁出过程中，对象中的旧地址会被记录下来，这样在迁出结束后V8会遍历它所记录的地址，将其更新为新的地址。由于标记过程中也记录了不同页之间的指针，此时也会更新这些指针的指向。注意，如果一个页非常“活跃”，比如其中有过多需要记录的指针，则地址记录会跳过它，等到下一轮垃圾回收再进行处理。 全停顿下表为3种主要垃圾回收算法的简单比较 在 Mark-Sweep 和 Mark-Compact 之间，由于 Mark-Compact 需要移动对象，所以它的执行速度不可能很快，所以在取舍上，V8 主要使用 Mark-Sweep，在空间不足以从新生代中晋升过来的对象进行分配时才使用 Mark-Compact 。为了避免出现 JavaScript应用逻辑与垃圾回收器看到的不一致的情况，垃圾回收的3种算法都需要将应用逻辑暂停下来，这种行为称为“全停顿” (stop-the-world)。 由于新生代配置的空间较小，存活对象较少，全停顿对新生代影响不大。但老生代通常配置的空间较大，且存活对象较多，全堆垃圾回收（full垃圾回收）的标记、清除、整理等动作造成的停顿就会比较可怕。 增量标记与惰性清理增量标记为了降低全堆垃圾回收带来的停顿时间，V8先从标记阶段入手，将原本要一口气停顿完成的动作改成增量标记(Incremental Marking)，也就是拆分为许多小“步进”，每做完一“步进”就让JavaScript应用逻辑执行一小会儿，垃圾回收和应用逻辑交替执行直到标记阶段完成。 增量标记允许堆的标记发生在几次5-10毫秒（移动设备）的小停顿中。增量标记在堆的大小达到一定的阈值时启用，启用之后每当一定量的内存分配后，脚本的执行就会停顿并进行一次增量标记。就像普通的标记一样，增量标记也是一个深度优先搜索，并同样采用白灰黑机制来分类对象。 但增量标记和普通标记不同的是，对象的图谱关系可能发生变化！我们需要特别注意的是，那些从黑对象指向白对象的新指针。回忆一下，黑对象表示其已完全被垃圾回收器扫描，并不会再进行二次扫描。因此如果有“黑→白”这样的指针出现，我们就有可能将那个白对象漏掉，错当死对象处理掉。（标记过程结束后剩余的白对象都被认为是死对象。）于是我们不得不再度启用写屏障。现在写屏障不仅记录“老→新”指针，同时还要记录“黑→白”指针。一旦发现这样的指针，黑对象会被重新染色为灰对象，重新放回到双端队列中。当算法将该对象取出时，其包含的指针会被重新扫描，这样活跃的白对象就不会漏掉。 惰性清理增量标记完成后，惰性清理就开始了。所有的对象已被处理，因此非死即活，堆上多少空间可以变为空闲已经成为定局。此时我们可以不急着释放那些空间，而将清理的过程延迟一下也并无大碍。因此无需一次清理所有的页，垃圾回收器会视需要逐一进行清理，直到所有的页都清理完毕。这时增量标记又蓄势待发了。 在两段的GC程序之间，引用关系可能发生了变化。所以，这种GC算法也要写屏障，来记录引用关系的变化。虽然这种方式控制了中断最高时间，但是由于中断次数增加，GC总时间是增加的。 并发标记并发式 GC（concurrent），即在垃圾回收的同时不需要停止程序的运行，两者可以同时进行，只有在个别时候需要短暂停下来让垃圾回收器做一些特殊的操作。但是这种方式也要面对增量回收的问题，所以也要进行写屏障操作。 一般能在垃圾回收的过程中修改对象的存在，不管是垃圾回收器本身还是运行时，或者是正在执行的程序，都统称为 mutator（翻译不详）。 增量标记和并发标记对程序执行更宽松的GC，都需要运行时从整体设计上保证mutator不会在垃圾回收的过程中与垃圾回收器同时修改对象，造成无法预料的后果。比如清洁阿姨打扫一个房间的时候可以把房间的门先关上，这样熊孩子就进不来了，但熊孩子们依然可以在屋子里的其他地方活动。在程序运行的同时进行垃圾回收虽然可能导致垃圾回收的周期变长（即降低了垃圾回收单位时间内的吞吐量），但是可以降低每次暂停的时间，进而提高程序的响应效率。 然而这种方式也并未做到完全不暂停原程序的运行，在某些特定的GC阶段还是要暂停原程序。 准确式 GC (Accurate GC)虽然 ECMA 中没有规定整数类型，Number 都是 IEEE 浮点数，但是由于在 CPU 上浮点数相关的操作通常比整型操作要慢，大多数的 Javascript 引擎都在底层实现中引入了整型，用于提升for循环和数组索引等场景的性能，并配以一定的技巧来将指针和整数（可能还有浮点数）“压缩”到同一种数据结构中节省空间。 在 V8 中，对象都按照 4 字节（32 位机器）或者 8 字节（64 位机器）对齐，因此对象的地址都能被 4 或者 8 整除，这意味着地址的二进制表示最后 2 位或者 3 位都会是 0，也就是说所有指针的这几位是可以空出来使用的。如果将另一种类型的数据的最后一位也保留出来另作他用，就可以通过判断最后一位是 0 还是 1，来直接分辨两种类型。那么，这另一种类型的数据就可以直接塞在前面几位，而不需要沿着一个指针去读取它的实际内容。在 V8 的语境内这种结构叫做小整数（SMI, small integer），这是语言实现中历史悠久的常用技巧 tagging 的一种。V8 预留所有的字（word，32位机器是 4 字节，64 位机器是8字节）的最后一位用于标记（tag）这个字中的内容的类型，1 表示指针，0 表示整数，这样给定一个内存中的字，它能通过查看最后一位快速地判断它包含的指针还是整数，并且可以将整数直接存储在字中，无需先通过一个指针间接引用过来，节省空间。 由于 V8 能够通过查看字的最后一位，快速地分辨指针和整数，在GC的时候，V8能够跳过所有的整数，更快地沿着指针扫描堆中的对象。由于在 GC 的过程中，V8 能够准确地分辨它所遍历到的每一块内存的内容属于什么类型，因此V8的垃圾回收器是准确式的。与此相对的是保守式 GC，即垃圾回收器因为某些设计导致无法确定内存中内容的类型，只能保守地先假设它们都是指针然后再加以验证，以免误回收不该回收的内存，因此可能误将数据当作指针，进而误以为一些对象仍然被引用，无法回收而浪费内存。同时因为保守式的垃圾回收器没有十足的把握区分指针和数据，也就不能确保自己能安全地修改指针，无法使用那些需要移动对象，更新指针的算法。 准确式的 GC 避免了保守式 GC 带来的弊端，能够尽早无遗漏地回收内存，并且能够在GC过程中移动对象以缓解内存碎片问题。]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>nodeJS</tag>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[告别原生，打造自己的topBar]]></title>
    <url>%2Farchives%2Fundefined.html</url>
    <content type="text"><![CDATA[前段时间项目忙到一半，产品突然说h5页面要加个top-bar（之前说好的混合开发呢）。WFT，项目做到了一半，突然要加这个；看了下设计图，大概是这样的经过认真分析，总结出了几种制作top-bar的方法； 方法一直接在view-router外添加，在路由处配置是否显示该top-bar即可路由配置12&#123; path: 'xxx', name: 'xxx', component: xxx, meta: &#123; title: 'xxxxx', topBar: false &#125; &#125; // topBar 为false则不显示` top-bar组件大致如下12345678910111213&lt;template&gt; &lt;div class=&quot;top-bar&quot; v-if=&quot;$route.meta.topBar !== false&quot;&gt; &#123;&#123;$route.meta.title&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;topBar&apos;&#125;&lt;/script&gt;&lt;style lang=&quot;sass&quot; scoped&gt;&lt;/style&gt; 然后在app.vue内引入TopBar组件1234567891011121314151617&lt;template&gt; &lt;div id="app"&gt; &lt;top-bar&gt;&lt;/top-bar&gt; &lt;router-view class="container"&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import TopBar from '@/components/common/TopBar'export default &#123; name: 'App', components: &#123; TopBar &#125;&#125;&lt;/script&gt; 优点 直接在vue入口配置，直观 通过路由传参控制其显示隐藏，配置简单 当前项目代码改动小 缺点 位置相对固定，不能放在router-view，会被router-view内的组件覆盖掉 无法动态修改title内容（原因是meta对象为只读），若想动态修改title，需脱离vue环境来操纵dom 方法二全局注册top-bar组件，在需要的页面调用； index.js内添加12import TopBar from '@/components/common/TopBar'Vue.components(TopBar) 页面内，将meta 赋值给当前页面的 page 对象1&lt;top-bar&gt;&#123;&#123;page.title&#125;&#125;&lt;/top-bar&gt; 路由配置不变 优点 在router-view内外皆可使用 可动态修改title值 操作简单，新手必备 缺点 使用起来比较麻烦，每次都需要手动调用 每个都页面要手动去存一个对象，用来改变title的值，重复代码多 当前项目代码改动大 方法三创建一个TopBar的组件构造器，需要extend，在每次路由跳转的时候，生成一个构造器实例；此方法的难点在于如何在路由跳转的时候，获取TopBar组件的实例；有以下注意点 获取组件实例：这里我们通过 $mount方法来获取组件实例;$mount会在vue内调用compile方法；编译后，我们便可拿到$el;从而进行手动挂载； 模板数据：在beforeRouteEnter钩子函数内获取 每个page都要执行，因此将此方法放到全局的mixin内，页面加载及路由跳转的时候，自动执行 关于$mount用法,可以参考官网 点击这里 mixin 如下， topBarMixin.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import Vue from 'vue'import '@/style/topBar.scss'let TopBar = nulllet App = nullconst getApp = function (vm) &#123; App = vm.$el return App&#125;const clearTopBar = function () &#123; if (TopBar) &#123; // 先清掉之前的，防止keep-alive的cache产生多个topbar const topBarElement = TopBar.$el const parentNode = topBarElement.parentNode parentNode.removeChild(topBarElement) &#125;&#125;const compile = function (meta) &#123; const show = (meta.topBar !== false) const title = meta.title || '' if (!show) &#123; return &#125; clearTopBar() // 先清除之前的TopBar const TopBarComponent = Vue.extend(&#123; data () &#123; return &#123; show, title &#125; &#125;, template: ` // 模板 &lt;div class="xsj-top-bar" v-if="show"&gt; &lt;div class="xsj-top-bar-content"&gt; &lt;div class="top-bar-arrow" @click="back"&gt; &lt;icon name="return" class="return"&gt;&lt;/icon&gt; &lt;/div&gt; &lt;div class="top-bar-title"&gt;&#123;&#123;title&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;` &#125;) TopBar = new TopBarComponent().$mount() // 挂载获取实例 if (App.nodeType === 1) &#123; App.insertBefore(TopBar.$el, App.firstChild) &#125; else &#123; throw new Error('无法给非元素节点增加topbar') &#125;&#125;export default &#123; methods: &#123; _resetTitle (title = TopBar.title) &#123; // 可手动调用修改当前title的内容 this.$nextTick(() =&gt; &#123; // 在页面模板挂载上去以后，执行 if (TopBar.show) &#123; TopBar.title = title document.title = title &#125; &#125;) &#125; &#125;, beforeRouteEnter (to, from, next) &#123; const meta = to.meta next(vm =&gt; &#123; getApp(vm) compile(meta) &#125;) &#125;&#125; index.js 内直接调用Vue.mixin(topBarMixin) 优点 通过路由传参控制其显示隐藏，配置简单 当前项目代码改动小 缺点 TopBar为动态插入，所以会引起页面重排 对于有keep-alive的页面，需要清除之前的TopBar，不然每次enter就会增加一个TopBar实例 方法四方法四和方法三实现逻辑差不多，只不过把组件构造器换为组件实例TopBar.vue； 组件实例 引入组件，$mount挂载获取实例 数据方面：由于TopBar无法拿到当前route的信息，所以需要通过props传入 TopBar.vue如下123456789101112131415161718&lt;template&gt; &lt;div class=&quot;top-bar&quot; v-if=&quot;bar.topBar !== false&quot;&gt; &#123;&#123;bar.title&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;TopBar&apos;, props: &#123; bar: &#123; type: Object, default () &#123; return &#123;&#125; &#125; &#125; &#125;&#125;&lt;/script&gt; mixin 如下， topBarMixin.js文件12345678910111213141516171819202122232425import Vue from &apos;vue&apos;import TopBar from &apos;@/components/common/TopBar&apos; // 引入TopBar组件let App = nullconst getApp = function (vm) &#123; App = vm.$el return App&#125;export default &#123; name: &apos;AddTopBar&apos;, beforeRouteEnter (to, from, next) &#123; next(vm =&gt; &#123; getApp(vm) const tb = new Vue(TopBar).$mount() // 挂载获取实例 if (App.nodeType === 1) &#123; clearTopBar() // 先清掉之前的TopBar，防止keep-alive的cache产生多个topbar App.insertBefore(tb.$el, App.firstChild) tb._props.bar = to.meta // 将路由数据传给top-bar &#125; else &#123; throw new Error(&apos;无法给非元素节点增加topbar&apos;) &#125; &#125;) &#125;&#125; 入口处调用Vue.mixin(topBarMixin)即可 优点 通过路由传参控制其显示隐藏，配置简单 当前项目代码改动小 可手动设置props，动态修改title 组件分离出来，便于维护和扩展 缺点 TopBar为动态插入，所以会引起页面重排 对于有keep-alive的页面，需要清除之前的TopBar，不然每次enter页面就会增加一个TopBar实例 最后本文涉及的知识点和细节点还是蛮多的，自己在整理的时候，也认真的消化吸收了一波；有些小知识点，写起来比较占篇幅，再者比较时间匆忙，笔者在此就一笔带过了。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>topBar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[嫌图标插件太大？canvas自制罗盘仪]]></title>
    <url>%2Farchives%2Fundefined.html</url>
    <content type="text"><![CDATA[最近项目需要做一个罗盘仪效果，网上找了下图表插件，感觉都挺大；改成自己需要的ui又十分麻烦，干脆自己写个练练手，说干就干。 简单的罗盘仪效果 效果图如下贴代码(基于VUE) 123456789&lt;template&gt; &lt;div class="gauge"&gt; &lt;div class="progress" ref="progress"&gt; &lt;canvas&gt;浏览器不支持Canvas,请升级或改用其它浏览器&lt;/canvas&gt; &lt;/div&gt; &lt;div class="invite"&gt;&#123;&#123;text&#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;` 逻辑还是比较简单的 先初始化一个canvas，定义canvas的宽高 需要注意的是canvas元素有自己默认的宽高： 默认宽 300px, 高 150px canvas.width,canvas.height 和 canvas.style.width,canvas.style.height是两个不一样的概念，canva.width|height 是canvas画布真实的宽高，而canva.style.width|height 是canvas画布容器的宽高；真是宽高在容器宽高内会进行缩放；如图 在Retina屏上面，canvas会出现模糊的情况；这是因为 canvas 不是矢量图，而是像图片一样是位图模式的。高 dpi 显示设备意味着每平方英寸有更多的像素。也就是说二倍屏，浏览器就会以2个像素点的宽度来渲染一个像素，该 canvas 在 Retina 屏幕下相当于占据了2倍的空间，相当于图片被放大了一倍，因此绘制出来的图片文字等会变模糊。所以我们需要算出屏幕像素比 ratio = window.devicePixelRatio || 1 现在，我们要开始画画了；首先是画一个半圆，然后是进度条（小球的尾巴），还有小球；这里比较麻烦的是小球和进度条的运行轨迹，因为小球和进度条的运行轨迹都是基于半圆的圆弧 小球完全是在圆弧上面运动的，小球的半径为圆弧的宽度 / 2；重点是要算出当前小球的圆心坐标才能画出小球的位置和形状；所以我们需要定义一个单位时间的弧度值angle，来计算小球单位时间的位置，speed不断增加，小球不断变化位置，每次变化位置，需要抹去之前画的小球，进度条；接着就是套公式了 进度条，这个简单，只半圆弧的基础上，另外画一条弧，弧度为总弧度（Math.PI）和当前进度的比值 现在开始，要让罗盘仪动起来！！定义一个变量speed（表示增加的弧度值），通过 requestAnimationFrame 进行动画，更显平滑流畅，空值speed的速度，就可以空值罗盘仪的变化方式 最后，给罗盘仪加点文字；主要用到fillStyle，fillText，textAlign；这里有个坑需要注意一下，textAlign的是相对于画布中fillText的起始坐标来的；跟css的textAlign不一样 上图起始点的坐标都在中间，textAlign展现形式不同。 所有的逻辑代码，整合如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157const ratio = window.devicePixelRatio || 1 // Retina上面显示模糊，兼容苹果手机const bound = &#123; start: Math.PI + 0.1, end: Math.PI * 2 - 0.1&#125;const colors = [&#123; // 定义颜色，不同等级，弧度的颜色不一样 start: 'ffb488', end: 'ffddc2'&#125;, &#123; start: 'ffb488', end: 'ffddc2'&#125;, &#123; start: 'babfcd', end: 'dde1eb'&#125;, &#123; start: 'e4b23f', end: 'ffe892'&#125;]let ctx = nulllet r = 0 // 半径let lineWidth = 0let layerColor = 'rgba(255,255,255, 0.5)'let width = 0let height = 0let angle = 0.1let endAngle = 0let speed = 0.04let lineCap = 'round'let color = nullexport default &#123; data () &#123; return &#123; canvas: null, width: 0, height: 0, color: &#123;&#125; &#125; &#125;, props: &#123; rate: &#123; type: Number || String, default: 0 &#125;, count: &#123; type: Number || String, default: 0 &#125;, silver: &#123; type: Number || String, default: 0 &#125;, level: &#123; type: Number, default: 1 &#125;, text: &#123; type: String, default: '' &#125; &#125;, methods: &#123; initCanvas () &#123; const container = this.$refs['progress'] const width = ~~container.clientWidth const height = ~~container.clientHeight this.canvas = container.getElementsByTagName('canvas')[0] this.canvas.width = width * ratio this.canvas.height = height * ratio this.canvas.style.width = width + 'px' this.canvas.style.height = height + 'px' this.color = colors[ this.level - 1 ] // this.canvas.getContext('2d').scale(ratio, ratio) &#125;, layer () &#123; // 半圆 const grd = ctx.createLinearGradient(0, height, width, height) grd.addColorStop(0, layerColor) grd.addColorStop(1, layerColor) ctx.beginPath() ctx.strokeStyle = grd ctx.lineWidth = lineWidth ctx.lineCap = lineCap ctx.arc(width / 2, height, r, bound.start, bound.end) ctx.stroke() ctx.closePath() &#125;, ball () &#123; // 小圆球 const start = Math.max(angle, 0) const end = Math.min(angle, Math.PI - 0.1) ctx.beginPath() ctx.fillStyle = '#fff' ctx.arc(width / 2 - Math.cos(start) * r, height - Math.sin(end) * r, lineWidth / 2 + 2, 0, Math.PI * 2) ctx.fill() ctx.closePath() &#125;, step () &#123; // 进度条 const start = Math.min(Math.PI + angle, bound.start) const end = Math.min(Math.PI + angle, bound.end) const progressGrd = ctx.createLinearGradient(0, height, width, height) progressGrd.addColorStop(0, `#$&#123;color.start&#125;`) progressGrd.addColorStop(1, `#$&#123;color.end&#125;`) ctx.beginPath() ctx.strokeStyle = progressGrd ctx.lineWidth = lineWidth ctx.lineCap = lineCap ctx.arc(width / 2, height, r, start, end) ctx.stroke() ctx.closePath() &#125;, animate () &#123; if (endAngle &lt; angle) &#123; return window.cancelAnimationFrame(this.animate) &#125; else &#123; ctx.clearRect(0, 0, width, height) this.setText() this.layer() this.step() this.ball() window.requestAnimationFrame(this.animate) angle += speed // 匀速增加 &#125; &#125;, setText () &#123; ctx.font = `$&#123;12 * ratio&#125;px 微软雅黑` ctx.fillStyle = '#fff' ctx.textAlign = 'center' ctx.fillText('已邀会员', width / 2, height / 2, width) ctx.font = `$&#123;32 * ratio&#125;px 微软雅黑` ctx.fillText(this.count || 0, width / 2, height - 5, width) &#125;, init () &#123; this.initCanvas() ctx = this.canvas.getContext('2d') width = this.canvas.width height = this.canvas.height color = this.color lineWidth = ~~(width / 18) r = width / 2 - lineWidth endAngle = Math.max(Math.PI * this.rate, angle) this.animate() &#125; &#125;, watch: &#123; rate: &#123; handler () &#123; this.init() &#125; &#125; &#125;, beforeDestroy () &#123; angle = 0.1 endAngle = 0 &#125;&#125;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex-basis与width在布局中的作用]]></title>
    <url>%2Farchives%2Fundefined.html</url>
    <content type="text"><![CDATA[错误场景今天在切图的时候，发现自己的按钮怎么都无法在右侧对齐如图html的结构如下1234567891011&lt;ul&gt; &lt;li&gt; &lt;span&gt;手机号&lt;/span&gt; &lt;input type="text" placeholder="请输入注册手机号"&gt; &lt;/li&gt; &lt;li&gt; &lt;span&gt;验证码&lt;/span&gt; &lt;input type="text" placeholder="请输入验证码"&gt; &lt;i class="check-code unable"&gt;获取验证码&lt;/i&gt; &lt;/li&gt;&lt;/ul&gt; css为flex布局，左侧文字flex-basis固定宽度，中间的input宽度auto自动grow；右侧验证码flex-basis固定宽度在不加验证码的情况下，正常显示，加入验证码以后1234567891011121314151617181920212223242526272829303132li &#123; // 每行的样式 display: flex; height: .52rem; margin-left: .16rem; padding-right: .16rem; font-size: 16px; justify-content: space-between; align-items: center; color: #333; border-bottom: solid 1px #eee; span &#123; flex: 0 0 .9rem; &#125; input &#123; // 输入框 height: 100%; font-size: 16px; flex: 1 0 auto; &#125; .check-code &#123; // 验证码 border: solid 1px #E31335; flex: 0 0 .9rem; text-align: center; height: .24rem; line-height: .24rem; color: #E31335; font-size: 12px; border-radius: 3px; &amp;.unable &#123; color: #C1C2C2; border: solid 1px #C1C2C2; &#125;&#125; 解决思路正常来说，验证码这块里是不会伸展的；而input有定义了flex: 1 0 auto;说明input会自动伸展占据当前盒子中剩余的空间。但是现在不仅占据了盒子剩余的空间，甚至超出了剩余的空间；验证码被挤到了盒子外边。所以我想到的是宽度这块出现了问题，在布局中，左边文字和右边的验证码宽度都是固定的，所以最后可能出现问题的是input的宽度；这里跟input宽度相关的便是flex-basis flex-basis flex-basis 指定了 flex 元素在主轴方向上的初始大小。如果不使用 box-sizing 来改变盒模型的话，那么这个属性就决定了 flex 元素的内容盒（content-box）的宽或者高（取决于主轴的方向）的尺寸大小。即 如果没有设置flex-basis属性，那么flex-basis的大小就是项目的width属性的大小如果没有设置width属性，那么flex-basis的大小就是项目内容(content)的大小 而当前我们的input并没有定义明确的宽度；所以参照的是默认的宽度；然后，我们给input定义一个具体的宽度，便可解决（值不可过大）如：width: 100px; 更多关于flex-basis和width的区别和联系，可以参考https://gedd.ski/post/the-difference-between-width-and-flex-basis/或者翻译版https://www.jianshu.com/p/17b1b445ecd4]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>flex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuex中modules的使用场景和注意事项]]></title>
    <url>%2Farchives%2Fundefined.html</url>
    <content type="text"><![CDATA[store 拆分成 modules 过程之前的项目一直是store下面放各种js文件（index.js、state.js、getter.js、mutation-types.js、mutations.js、action.js）;如下图 123456└── store ├── index.js # 我们组装模块并导出 store 的地方 ├── actions.js # 根级别的 action ├── mutations.js # 根级别的 mutation ├── state.js # 根级别的 state └── getter.js 使用单一的状态树，应用的所有状态都会集中在一个比较大的对象上面，随着项目需求的不断增加，状态树也会变得越来越臃肿，增加了状态树维护的复杂度,而且代码变得沉长；因此我们需要modules来为我们的状态树分隔成不同的模块，每个模块拥有自己的state，getters，mutations，actions；而且允许每个module里面嵌套子module；如下： 12345678└── store ├── index.js # 我们组装模块并导出 store 的地方 ├── actions.js # 根级别的 action ├── mutations.js # 根级别的 mutation ├── state.js # 根级别的 state └── modules ├── module1.js # 模块1的state树 └── module2.js # 模块2的state树 模块module1.js内部的代码结构如下12345678910111213141516171819202122232425262728import &#123; WIDTH_ADD &#125; from '@/store/mutation-types.js' // 引入事件类型export default &#123; namespaced: true, state: &#123; width: 100, height: 50 &#125;, getters: &#123; modulegGetWidth(state, getters, rootState) &#123; return state.width &#125;, modulegetHeight(state, getters, rootState) &#123; return state.height &#125; &#125;, mutations: &#123; [WIDTH_ADD](state) &#123; // 使用常量替代 Mutation 事件类型 return state.width++ &#125;, addHeight(state) &#123; // 不使用常量 return state.height++ &#125; &#125;, actions: &#123; &#125;&#125; 注册到根state。index.js如下123456789101112131415import state from './state'import getters from './getters'import mutations from './mutations'import actions from './actions'import module1 from './modules/module1.js' // 引入module1export default &#123; state, getters, mutations, actions, modules: &#123; module1 // 注册完成 &#125;&#125; 在组件内打印state。1console.log(this.$store.state) 如图由上图，可以看到，module1已经被我们添加到了当前的store.state内; 需要注意的 Vuex在组件中computed中使用的时候，计算属性不能和state的数据项同名（同名了也不会报错，就是获取不了数据了） 有一点值得注意的是：当我们在组件的计算属性中使用module里面的getters的时候,计算属性不和state的数据项同名这条规则貌似不生效，具体原因还不知道，如果有知道的大佬帮忙指点一下 默认情况下，没有设置命名空间的时候，模块内部的 action、mutation 和 getter 是(除了state)注册在全局命名空间的（如果有重名就会报错 [vuex] duplicate getter key: [method]）——这样使得多个模块能够对同一 mutation 或 action 作出响应。 解决方法是加命名空间 namespaced: true 如何在页面里面引用module 在modules内的每个模块加入命名空间 1namespaced: true vue文件内也可引入createNamespacedHelpers 12import &#123; createNamespacedHelpers &#125; from 'vuex'const &#123; mapState, mapActions &#125; = createNamespacedHelpers('mudole1') 注册到组件中12345678910111213import &#123; mapState, mapMutations &#125; from "vuex"computed: &#123; ...mapState('module1', &#123; width: state =&gt; state.width, // 关联, 此处的state 为 module1/state height: state =&gt; state.height &#125;) &#125;,methods: &#123; ...mapMutations('module1', &#123; // 命名空间module1 widthAdd: 'WIDTH_ADD', // 通过mutation-types.js addHeight: 'addHeight' // 直接加在mutations上面的方法 &#125;),&#125; 如何在模块中访问全局内容？ 如果你希望使用全局 state 和 getter，rootState 和 rootGetter 会作为第三和第四参数传入 getter，也会通过 context 对象的属性传入 action。 若需要在全局命名空间内分发 action 或提交 mutation，将 { root: true } 作为第三参数传给 dispatch 或 commit 即可。其实这块，作者在文档中已经说明的很清楚了，具体的链接：详细链接 划分模块的好处 state更为容易管理，尤其在团队人数多的时候，自己负责自己的state，既保证store了完整的状态树，又避免了相互之间的state冲突 不管是命名，或是操作 state 都会变得更加扁平和直观]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vuex</tag>
        <tag>state</tag>
      </tags>
  </entry>
</search>
