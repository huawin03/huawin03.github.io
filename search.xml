<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vuex中modules的使用场景和注意事项]]></title>
    <url>%2F2019%2F01%2F24%2Fvuex%E4%B8%ADmodules%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[store 拆分成 modules 过程之前的项目一直是store下面放各种js文件（index.js、state.js、getter.js、mutation-types.js、mutations.js、action.js）;如下图 123456└── store ├── index.js # 我们组装模块并导出 store 的地方 ├── actions.js # 根级别的 action ├── mutations.js # 根级别的 mutation ├── state.js # 根级别的 state └── getter.js 使用单一的状态树，应用的所有状态都会集中在一个比较大的对象上面，随着项目需求的不断增加，状态树也会变得越来越臃肿，增加了状态树维护的复杂度,而且代码变得沉长；因此我们需要modules来为我们的状态树分隔成不同的模块，每个模块拥有自己的state，getters，mutations，actions；而且允许每个module里面嵌套子module；如下： 12345678└── store ├── index.js # 我们组装模块并导出 store 的地方 ├── actions.js # 根级别的 action ├── mutations.js # 根级别的 mutation ├── state.js # 根级别的 state └── modules ├── module1.js # 模块1的state树 └── module2.js # 模块2的state树 模块module1.js内部的代码结构如下12345678910111213141516171819202122232425262728import &#123; WIDTH_ADD &#125; from '@/store/mutation-types.js' // 引入事件类型export default &#123; namespaced: true, state: &#123; width: 100, height: 50 &#125;, getters: &#123; modulegGetWidth(state, getters, rootState) &#123; return state.width &#125;, modulegetHeight(state, getters, rootState) &#123; return state.height &#125; &#125;, mutations: &#123; [WIDTH_ADD](state) &#123; // 使用常量替代 Mutation 事件类型 return state.width++ &#125;, addHeight(state) &#123; // 不使用常量 return state.height++ &#125; &#125;, actions: &#123; &#125;&#125; 注册到根state。index.js如下123456789101112131415import state from './state'import getters from './getters'import mutations from './mutations'import actions from './actions'import module1 from './modules/module1.js' // 引入module1export default &#123; state, getters, mutations, actions, modules: &#123; module1 // 注册完成 &#125;&#125; 在组件内打印state。1console.log(this.$store.state) 如图由上图，可以看到，module1已经被我们添加到了当前的store.state内; 需要注意的 Vuex在组件中computed中使用的时候，计算属性不能和state的数据项同名（同名了也不会报错，就是获取不了数据了） 有一点值得注意的是：当我们在组件的计算属性中使用module里面的getters的时候,计算属性不和state的数据项同名这条规则貌似不生效，具体原因还不知道，如果有知道的大佬帮忙指点一下 默认情况下，没有设置命名空间的时候，模块内部的 action、mutation 和 getter 是(除了state)注册在全局命名空间的（如果有重名就会报错 [vuex] duplicate getter key: [method]）——这样使得多个模块能够对同一 mutation 或 action 作出响应。 解决方法是加命名空间 namespaced: true 如何在页面里面引用module 在modules内的每个模块加入命名空间 namespaced: true vue文件内也可引入createNamespacedHelpers 12345678910111213141516171819202122232425262728import &#123; createNamespacedHelpers &#125; from &apos;vuex&apos;const &#123; mapState, mapActions &#125; = createNamespacedHelpers(&apos;mudole1&apos;)``` 2. 注册到组件中 ```javascriptimport &#123; mapState, mapMutations &#125; from &quot;vuex&quot;computed: &#123; ...mapState(&apos;module1&apos;, &#123; width: state =&gt; state.width, // 关联, 此处的state 为 module1/state height: state =&gt; state.height &#125;) &#125;,methods: &#123; ...mapMutations(&apos;module1&apos;, &#123; // 命名空间module1 widthAdd: &apos;WIDTH_ADD&apos;, // 通过mutation-types.js addHeight: &apos;addHeight&apos; // 直接加在mutations上面的方法 &#125;),&#125;``` 3. 注册完成，使用```javascript created() &#123; this.widthAdd() // 将 `this.widthAdd()` 映射为 `this.$store.commit(&apos;module1/widthadd&apos;)` console.log(this.width) // this.width已经变为commit以后的值&#125; 如何在模块中访问全局内容？ 如果你希望使用全局 state 和 getter，rootState 和 rootGetter 会作为第三和第四参数传入 getter，也会通过 context 对象的属性传入 action。 若需要在全局命名空间内分发 action 或提交 mutation，将 { root: true } 作为第三参数传给 dispatch 或 commit 即可。其实这块，作者在文档中已经说明的很清楚了，具体的链接：详细链接 划分模块的好处 state更为容易管理，尤其在团队人数多的时候，自己负责自己的state，既保证store了完整的状态树，又避免了相互之间的state冲突 不管是命名，或是操作 state 都会变得更加扁平和直观]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vuex</tag>
        <tag>state</tag>
      </tags>
  </entry>
</search>
