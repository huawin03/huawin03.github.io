<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[flex-basis与width在布局中的作用]]></title>
    <url>%2F2019%2F02%2F01%2Fflex-basis%E4%B8%8Ewidth%E5%9C%A8%E5%B8%83%E5%B1%80%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[错误场景今天在切图的时候，发现自己的按钮怎么都无法在右侧对齐如图html的结构如下1234567891011&lt;ul&gt; &lt;li&gt; &lt;span&gt;手机号&lt;/span&gt; &lt;input type="text" placeholder="请输入注册手机号"&gt; &lt;/li&gt; &lt;li&gt; &lt;span&gt;验证码&lt;/span&gt; &lt;input type="text" placeholder="请输入验证码"&gt; &lt;i class="check-code unable"&gt;获取验证码&lt;/i&gt; &lt;/li&gt;&lt;/ul&gt; css为flex布局，左侧文字flex-basis固定宽度，中间的input宽度auto自动grow；右侧验证码flex-basis固定宽度在不加验证码的情况下，正常显示，加入验证码以后1234567891011121314151617181920212223242526272829303132li &#123; // 每行的样式 display: flex; height: .52rem; margin-left: .16rem; padding-right: .16rem; font-size: 16px; justify-content: space-between; align-items: center; color: #333; border-bottom: solid 1px #eee; span &#123; flex: 0 0 .9rem; &#125; input &#123; // 输入框 height: 100%; font-size: 16px; flex: 1 0 auto; &#125; .check-code &#123; // 验证码 border: solid 1px #E31335; flex: 0 0 .9rem; text-align: center; height: .24rem; line-height: .24rem; color: #E31335; font-size: 12px; border-radius: 3px; &amp;.unable &#123; color: #C1C2C2; border: solid 1px #C1C2C2; &#125;&#125; 解决思路正常来说，验证码这块里是不会伸展的；而input有定义了flex: 1 0 auto;说明input会自动伸展占据当前盒子中剩余的空间。但是现在不仅占据了盒子剩余的空间，甚至超出了剩余的空间；验证码被挤到了盒子外边。所以我想到的是宽度这块出现了问题，在布局中，左边文字和右边的验证码宽度都是固定的，所以最后可能出现问题的是input的宽度；这里跟input宽度相关的便是flex-basis flex-basis flex-basis 指定了 flex 元素在主轴方向上的初始大小。如果不使用 box-sizing 来改变盒模型的话，那么这个属性就决定了 flex 元素的内容盒（content-box）的宽或者高（取决于主轴的方向）的尺寸大小。即 如果没有设置flex-basis属性，那么flex-basis的大小就是项目的width属性的大小如果没有设置width属性，那么flex-basis的大小就是项目内容(content)的大小 而当前我们的input并没有定义明确的宽度；所以参照的是默认的宽度；然后，我们给input定义一个具体的宽度，便可解决（值不可过大）如：width: 100px; 更多关于flex-basis和width的区别和联系，可以参考https://gedd.ski/post/the-difference-between-width-and-flex-basis/或者翻译版https://www.jianshu.com/p/17b1b445ecd4]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>flex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuex中modules的使用场景和注意事项]]></title>
    <url>%2F2019%2F01%2F24%2Fvuex%E4%B8%ADmodules%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[store 拆分成 modules 过程之前的项目一直是store下面放各种js文件（index.js、state.js、getter.js、mutation-types.js、mutations.js、action.js）;如下图 123456└── store ├── index.js # 我们组装模块并导出 store 的地方 ├── actions.js # 根级别的 action ├── mutations.js # 根级别的 mutation ├── state.js # 根级别的 state └── getter.js 使用单一的状态树，应用的所有状态都会集中在一个比较大的对象上面，随着项目需求的不断增加，状态树也会变得越来越臃肿，增加了状态树维护的复杂度,而且代码变得沉长；因此我们需要modules来为我们的状态树分隔成不同的模块，每个模块拥有自己的state，getters，mutations，actions；而且允许每个module里面嵌套子module；如下： 12345678└── store ├── index.js # 我们组装模块并导出 store 的地方 ├── actions.js # 根级别的 action ├── mutations.js # 根级别的 mutation ├── state.js # 根级别的 state └── modules ├── module1.js # 模块1的state树 └── module2.js # 模块2的state树 模块module1.js内部的代码结构如下12345678910111213141516171819202122232425262728import &#123; WIDTH_ADD &#125; from '@/store/mutation-types.js' // 引入事件类型export default &#123; namespaced: true, state: &#123; width: 100, height: 50 &#125;, getters: &#123; modulegGetWidth(state, getters, rootState) &#123; return state.width &#125;, modulegetHeight(state, getters, rootState) &#123; return state.height &#125; &#125;, mutations: &#123; [WIDTH_ADD](state) &#123; // 使用常量替代 Mutation 事件类型 return state.width++ &#125;, addHeight(state) &#123; // 不使用常量 return state.height++ &#125; &#125;, actions: &#123; &#125;&#125; 注册到根state。index.js如下123456789101112131415import state from './state'import getters from './getters'import mutations from './mutations'import actions from './actions'import module1 from './modules/module1.js' // 引入module1export default &#123; state, getters, mutations, actions, modules: &#123; module1 // 注册完成 &#125;&#125; 在组件内打印state。1console.log(this.$store.state) 如图由上图，可以看到，module1已经被我们添加到了当前的store.state内; 需要注意的 Vuex在组件中computed中使用的时候，计算属性不能和state的数据项同名（同名了也不会报错，就是获取不了数据了） 有一点值得注意的是：当我们在组件的计算属性中使用module里面的getters的时候,计算属性不和state的数据项同名这条规则貌似不生效，具体原因还不知道，如果有知道的大佬帮忙指点一下 默认情况下，没有设置命名空间的时候，模块内部的 action、mutation 和 getter 是(除了state)注册在全局命名空间的（如果有重名就会报错 [vuex] duplicate getter key: [method]）——这样使得多个模块能够对同一 mutation 或 action 作出响应。 解决方法是加命名空间 namespaced: true 如何在页面里面引用module 在modules内的每个模块加入命名空间 1namespaced: true vue文件内也可引入createNamespacedHelpers 12import &#123; createNamespacedHelpers &#125; from 'vuex'const &#123; mapState, mapActions &#125; = createNamespacedHelpers('mudole1') 注册到组件中12345678910111213import &#123; mapState, mapMutations &#125; from "vuex"computed: &#123; ...mapState('module1', &#123; width: state =&gt; state.width, // 关联, 此处的state 为 module1/state height: state =&gt; state.height &#125;) &#125;,methods: &#123; ...mapMutations('module1', &#123; // 命名空间module1 widthAdd: 'WIDTH_ADD', // 通过mutation-types.js addHeight: 'addHeight' // 直接加在mutations上面的方法 &#125;),&#125; 如何在模块中访问全局内容？ 如果你希望使用全局 state 和 getter，rootState 和 rootGetter 会作为第三和第四参数传入 getter，也会通过 context 对象的属性传入 action。 若需要在全局命名空间内分发 action 或提交 mutation，将 { root: true } 作为第三参数传给 dispatch 或 commit 即可。其实这块，作者在文档中已经说明的很清楚了，具体的链接：详细链接 划分模块的好处 state更为容易管理，尤其在团队人数多的时候，自己负责自己的state，既保证store了完整的状态树，又避免了相互之间的state冲突 不管是命名，或是操作 state 都会变得更加扁平和直观]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vuex</tag>
        <tag>state</tag>
      </tags>
  </entry>
</search>
