<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[告别原生，打造自己的topBar]]></title>
    <url>%2F2019%2F04%2F10%2F20190410%2F</url>
    <content type="text"><![CDATA[前段时间项目忙到一半，产品突然说h5页面要加个top-bar（之前说好的混合开发呢）。WFT，项目做到了一半，突然要加这个；看了下设计图，大概是这样的经过认真分析，总结出了几种制作top-bar的方法； 方法一直接在view-router外添加，在路由处配置是否显示该top-bar即可路由配置12&#123; path: 'xxx', name: 'xxx', component: xxx, meta: &#123; title: 'xxxxx', topBar: false &#125; &#125; // topBar 为false则不显示` top-bar组件大致如下12345678910111213&lt;template&gt; &lt;div class=&quot;top-bar&quot; v-if=&quot;$route.meta.topBar !== false&quot;&gt; &#123;&#123;$route.meta.title&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;topBar&apos;&#125;&lt;/script&gt;&lt;style lang=&quot;sass&quot; scoped&gt;&lt;/style&gt; 然后在app.vue内引入TopBar组件1234567891011121314151617&lt;template&gt; &lt;div id="app"&gt; &lt;top-bar&gt;&lt;/top-bar&gt; &lt;router-view class="container"&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import TopBar from '@/components/common/TopBar'export default &#123; name: 'App', components: &#123; TopBar &#125;&#125;&lt;/script&gt; 优点 直接在vue入口配置，直观 通过路由传参控制其显示隐藏，配置简单 当前项目代码改动小 缺点 位置相对固定，不能放在router-view，会被router-view内的组件覆盖掉 无法动态修改title内容（原因是meta对象为只读），若想动态修改title，需脱离vue环境来操纵dom 方法二全局注册top-bar组件，在需要的页面调用； index.js内添加12import TopBar from '@/components/common/TopBar'Vue.components(TopBar) 页面内，将meta 赋值给当前页面的 page 对象1&lt;top-bar&gt;&#123;&#123;page.title&#125;&#125;&lt;/top-bar&gt; 路由配置不变 优点 在router-view内外皆可使用 可动态修改title值 操作简单，新手必备 缺点 使用起来比较麻烦，每次都需要手动调用 每个都页面要手动去存一个对象，用来改变title的值，重复代码多 当前项目代码改动大 方法三创建一个TopBar的组件构造器，需要extend，在每次路由跳转的时候，生成一个构造器实例；此方法的难点在于如何在路由跳转的时候，获取TopBar组件的实例；有以下注意点 获取组件实例：这里我们通过 $mount方法来获取组件实例;$mount会在vue内调用compile方法；编译后，我们便可拿到$el;从而进行手动挂载； 模板数据：在beforeRouteEnter钩子函数内获取 每个page都要执行，因此将此方法放到全局的mixin内，页面加载及路由跳转的时候，自动执行 关于$mount用法,可以参考官网 点击这里 mixin 如下， topBarMixin.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import Vue from 'vue'import '@/style/topBar.scss'let TopBar = nulllet App = nullconst getApp = function (vm) &#123; App = vm.$el return App&#125;const clearTopBar = function () &#123; if (TopBar) &#123; // 先清掉之前的，防止keep-alive的cache产生多个topbar const topBarElement = TopBar.$el const parentNode = topBarElement.parentNode parentNode.removeChild(topBarElement) &#125;&#125;const compile = function (meta) &#123; const show = (meta.topBar !== false) const title = meta.title || '' if (!show) &#123; return &#125; clearTopBar() // 先清除之前的TopBar const TopBarComponent = Vue.extend(&#123; data () &#123; return &#123; show, title &#125; &#125;, template: ` // 模板 &lt;div class="xsj-top-bar" v-if="show"&gt; &lt;div class="xsj-top-bar-content"&gt; &lt;div class="top-bar-arrow" @click="back"&gt; &lt;icon name="return" class="return"&gt;&lt;/icon&gt; &lt;/div&gt; &lt;div class="top-bar-title"&gt;&#123;&#123;title&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;` &#125;) TopBar = new TopBarComponent().$mount() // 挂载获取实例 if (App.nodeType === 1) &#123; App.insertBefore(TopBar.$el, App.firstChild) &#125; else &#123; throw new Error('无法给非元素节点增加topbar') &#125;&#125;export default &#123; methods: &#123; _resetTitle (title = TopBar.title) &#123; // 可手动调用修改当前title的内容 this.$nextTick(() =&gt; &#123; // 在页面模板挂载上去以后，执行 if (TopBar.show) &#123; TopBar.title = title document.title = title &#125; &#125;) &#125; &#125;, beforeRouteEnter (to, from, next) &#123; const meta = to.meta next(vm =&gt; &#123; getApp(vm) compile(meta) &#125;) &#125;&#125; index.js 内直接调用Vue.mixin(topBarMixin) 优点 通过路由传参控制其显示隐藏，配置简单 当前项目代码改动小 缺点 TopBar为动态插入，所以会引起页面重排 对于有keep-alive的页面，需要清除之前的TopBar，不然每次enter就会增加一个TopBar实例 方法四方法四和方法三实现逻辑差不多，只不过把组件构造器换为组件实例TopBar.vue； 组件实例 引入组件，$mount挂载获取实例 数据方面：由于TopBar无法拿到当前route的信息，所以需要通过props传入 TopBar.vue如下123456789101112131415161718&lt;template&gt; &lt;div class=&quot;top-bar&quot; v-if=&quot;bar.topBar !== false&quot;&gt; &#123;&#123;bar.title&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;TopBar&apos;, props: &#123; bar: &#123; type: Object, default () &#123; return &#123;&#125; &#125; &#125; &#125;&#125;&lt;/script&gt; mixin 如下， topBarMixin.js文件12345678910111213141516171819202122232425import Vue from &apos;vue&apos;import TopBar from &apos;@/components/common/TopBar&apos; // 引入TopBar组件let App = nullconst getApp = function (vm) &#123; App = vm.$el return App&#125;export default &#123; name: &apos;AddTopBar&apos;, beforeRouteEnter (to, from, next) &#123; next(vm =&gt; &#123; getApp(vm) const tb = new Vue(TopBar).$mount() // 挂载获取实例 if (App.nodeType === 1) &#123; clearTopBar() // 先清掉之前的TopBar，防止keep-alive的cache产生多个topbar App.insertBefore(tb.$el, App.firstChild) tb._props.bar = to.meta // 将路由数据传给top-bar &#125; else &#123; throw new Error(&apos;无法给非元素节点增加topbar&apos;) &#125; &#125;) &#125;&#125; 入口处调用Vue.mixin(topBarMixin)即可 优点 通过路由传参控制其显示隐藏，配置简单 当前项目代码改动小 可手动设置props，动态修改title 组件分离出来，便于维护和扩展 缺点 TopBar为动态插入，所以会引起页面重排 对于有keep-alive的页面，需要清除之前的TopBar，不然每次enter页面就会增加一个TopBar实例 最后本文涉及的知识点和细节点还是蛮多的，自己在整理的时候，也认真的消化吸收了一波；有些小知识点，写起来比较占篇幅，再者比较时间匆忙，笔者在此就一笔带过了。]]></content>
      <tags>
        <tag>vue</tag>
        <tag>topBar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[嫌图标插件太大？canvas自制罗盘仪]]></title>
    <url>%2F2019%2F04%2F04%2F%E5%AB%8C%E5%9B%BE%E6%A0%87%E6%8F%92%E4%BB%B6%E5%A4%AA%E5%A4%A7%EF%BC%9Fcanvas%E8%87%AA%E5%88%B6%E7%BD%97%E7%9B%98%E4%BB%AA%2F</url>
    <content type="text"><![CDATA[最近项目需要做一个罗盘仪效果，网上找了下图表插件，感觉都挺大；改成自己需要的ui又十分麻烦，干脆自己写个练练手，说干就干。 简单的罗盘仪效果 效果图如下贴代码(基于VUE) 123456789&lt;template&gt; &lt;div class="gauge"&gt; &lt;div class="progress" ref="progress"&gt; &lt;canvas&gt;浏览器不支持Canvas,请升级或改用其它浏览器&lt;/canvas&gt; &lt;/div&gt; &lt;div class="invite"&gt;&#123;&#123;text&#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;` 逻辑还是比较简单的 先初始化一个canvas，定义canvas的宽高 需要注意的是canvas元素有自己默认的宽高： 默认宽 300px, 高 150px canvas.width,canvas.height 和 canvas.style.width,canvas.style.height是两个不一样的概念，canva.width|height 是canvas画布真实的宽高，而canva.style.width|height 是canvas画布容器的宽高；真是宽高在容器宽高内会进行缩放；如图 在Retina屏上面，canvas会出现模糊的情况；这是因为 canvas 不是矢量图，而是像图片一样是位图模式的。高 dpi 显示设备意味着每平方英寸有更多的像素。也就是说二倍屏，浏览器就会以2个像素点的宽度来渲染一个像素，该 canvas 在 Retina 屏幕下相当于占据了2倍的空间，相当于图片被放大了一倍，因此绘制出来的图片文字等会变模糊。所以我们需要算出屏幕像素比 ratio = window.devicePixelRatio || 1 现在，我们要开始画画了；首先是画一个半圆，然后是进度条（小球的尾巴），还有小球；这里比较麻烦的是小球和进度条的运行轨迹，因为小球和进度条的运行轨迹都是基于半圆的圆弧 小球完全是在圆弧上面运动的，小球的半径为圆弧的宽度 / 2；重点是要算出当前小球的圆心坐标才能画出小球的位置和形状；所以我们需要定义一个单位时间的弧度值angle，来计算小球单位时间的位置，speed不断增加，小球不断变化位置，每次变化位置，需要抹去之前画的小球，进度条；接着就是套公式了 进度条，这个简单，只半圆弧的基础上，另外画一条弧，弧度为总弧度（Math.PI）和当前进度的比值 现在开始，要让罗盘仪动起来！！定义一个变量speed（表示增加的弧度值），通过 requestAnimationFrame 进行动画，更显平滑流畅，空值speed的速度，就可以空值罗盘仪的变化方式 最后，给罗盘仪加点文字；主要用到fillStyle，fillText，textAlign；这里有个坑需要注意一下，textAlign的是相对于画布中fillText的起始坐标来的；跟css的textAlign不一样 上图起始点的坐标都在中间，textAlign展现形式不同。 所有的逻辑代码，整合如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157const ratio = window.devicePixelRatio || 1 // Retina上面显示模糊，兼容苹果手机const bound = &#123; start: Math.PI + 0.1, end: Math.PI * 2 - 0.1&#125;const colors = [&#123; // 定义颜色，不同等级，弧度的颜色不一样 start: 'ffb488', end: 'ffddc2'&#125;, &#123; start: 'ffb488', end: 'ffddc2'&#125;, &#123; start: 'babfcd', end: 'dde1eb'&#125;, &#123; start: 'e4b23f', end: 'ffe892'&#125;]let ctx = nulllet r = 0 // 半径let lineWidth = 0let layerColor = 'rgba(255,255,255, 0.5)'let width = 0let height = 0let angle = 0.1let endAngle = 0let speed = 0.04let lineCap = 'round'let color = nullexport default &#123; data () &#123; return &#123; canvas: null, width: 0, height: 0, color: &#123;&#125; &#125; &#125;, props: &#123; rate: &#123; type: Number || String, default: 0 &#125;, count: &#123; type: Number || String, default: 0 &#125;, silver: &#123; type: Number || String, default: 0 &#125;, level: &#123; type: Number, default: 1 &#125;, text: &#123; type: String, default: '' &#125; &#125;, methods: &#123; initCanvas () &#123; const container = this.$refs['progress'] const width = ~~container.clientWidth const height = ~~container.clientHeight this.canvas = container.getElementsByTagName('canvas')[0] this.canvas.width = width * ratio this.canvas.height = height * ratio this.canvas.style.width = width + 'px' this.canvas.style.height = height + 'px' this.color = colors[ this.level - 1 ] // this.canvas.getContext('2d').scale(ratio, ratio) &#125;, layer () &#123; // 半圆 const grd = ctx.createLinearGradient(0, height, width, height) grd.addColorStop(0, layerColor) grd.addColorStop(1, layerColor) ctx.beginPath() ctx.strokeStyle = grd ctx.lineWidth = lineWidth ctx.lineCap = lineCap ctx.arc(width / 2, height, r, bound.start, bound.end) ctx.stroke() ctx.closePath() &#125;, ball () &#123; // 小圆球 const start = Math.max(angle, 0) const end = Math.min(angle, Math.PI - 0.1) ctx.beginPath() ctx.fillStyle = '#fff' ctx.arc(width / 2 - Math.cos(start) * r, height - Math.sin(end) * r, lineWidth / 2 + 2, 0, Math.PI * 2) ctx.fill() ctx.closePath() &#125;, step () &#123; // 进度条 const start = Math.min(Math.PI + angle, bound.start) const end = Math.min(Math.PI + angle, bound.end) const progressGrd = ctx.createLinearGradient(0, height, width, height) progressGrd.addColorStop(0, `#$&#123;color.start&#125;`) progressGrd.addColorStop(1, `#$&#123;color.end&#125;`) ctx.beginPath() ctx.strokeStyle = progressGrd ctx.lineWidth = lineWidth ctx.lineCap = lineCap ctx.arc(width / 2, height, r, start, end) ctx.stroke() ctx.closePath() &#125;, animate () &#123; if (endAngle &lt; angle) &#123; return window.cancelAnimationFrame(this.animate) &#125; else &#123; ctx.clearRect(0, 0, width, height) this.setText() this.layer() this.step() this.ball() window.requestAnimationFrame(this.animate) angle += speed // 匀速增加 &#125; &#125;, setText () &#123; ctx.font = `$&#123;12 * ratio&#125;px 微软雅黑` ctx.fillStyle = '#fff' ctx.textAlign = 'center' ctx.fillText('已邀会员', width / 2, height / 2, width) ctx.font = `$&#123;32 * ratio&#125;px 微软雅黑` ctx.fillText(this.count || 0, width / 2, height - 5, width) &#125;, init () &#123; this.initCanvas() ctx = this.canvas.getContext('2d') width = this.canvas.width height = this.canvas.height color = this.color lineWidth = ~~(width / 18) r = width / 2 - lineWidth endAngle = Math.max(Math.PI * this.rate, angle) this.animate() &#125; &#125;, watch: &#123; rate: &#123; handler () &#123; this.init() &#125; &#125; &#125;, beforeDestroy () &#123; angle = 0.1 endAngle = 0 &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[flex-basis与width在布局中的作用]]></title>
    <url>%2F2019%2F02%2F01%2Fflex-basis%E4%B8%8Ewidth%E5%9C%A8%E5%B8%83%E5%B1%80%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[错误场景今天在切图的时候，发现自己的按钮怎么都无法在右侧对齐如图html的结构如下1234567891011&lt;ul&gt; &lt;li&gt; &lt;span&gt;手机号&lt;/span&gt; &lt;input type="text" placeholder="请输入注册手机号"&gt; &lt;/li&gt; &lt;li&gt; &lt;span&gt;验证码&lt;/span&gt; &lt;input type="text" placeholder="请输入验证码"&gt; &lt;i class="check-code unable"&gt;获取验证码&lt;/i&gt; &lt;/li&gt;&lt;/ul&gt; css为flex布局，左侧文字flex-basis固定宽度，中间的input宽度auto自动grow；右侧验证码flex-basis固定宽度在不加验证码的情况下，正常显示，加入验证码以后1234567891011121314151617181920212223242526272829303132li &#123; // 每行的样式 display: flex; height: .52rem; margin-left: .16rem; padding-right: .16rem; font-size: 16px; justify-content: space-between; align-items: center; color: #333; border-bottom: solid 1px #eee; span &#123; flex: 0 0 .9rem; &#125; input &#123; // 输入框 height: 100%; font-size: 16px; flex: 1 0 auto; &#125; .check-code &#123; // 验证码 border: solid 1px #E31335; flex: 0 0 .9rem; text-align: center; height: .24rem; line-height: .24rem; color: #E31335; font-size: 12px; border-radius: 3px; &amp;.unable &#123; color: #C1C2C2; border: solid 1px #C1C2C2; &#125;&#125; 解决思路正常来说，验证码这块里是不会伸展的；而input有定义了flex: 1 0 auto;说明input会自动伸展占据当前盒子中剩余的空间。但是现在不仅占据了盒子剩余的空间，甚至超出了剩余的空间；验证码被挤到了盒子外边。所以我想到的是宽度这块出现了问题，在布局中，左边文字和右边的验证码宽度都是固定的，所以最后可能出现问题的是input的宽度；这里跟input宽度相关的便是flex-basis flex-basis flex-basis 指定了 flex 元素在主轴方向上的初始大小。如果不使用 box-sizing 来改变盒模型的话，那么这个属性就决定了 flex 元素的内容盒（content-box）的宽或者高（取决于主轴的方向）的尺寸大小。即 如果没有设置flex-basis属性，那么flex-basis的大小就是项目的width属性的大小如果没有设置width属性，那么flex-basis的大小就是项目内容(content)的大小 而当前我们的input并没有定义明确的宽度；所以参照的是默认的宽度；然后，我们给input定义一个具体的宽度，便可解决（值不可过大）如：width: 100px; 更多关于flex-basis和width的区别和联系，可以参考https://gedd.ski/post/the-difference-between-width-and-flex-basis/或者翻译版https://www.jianshu.com/p/17b1b445ecd4]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>flex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuex中modules的使用场景和注意事项]]></title>
    <url>%2F2019%2F01%2F24%2Fvuex%E4%B8%ADmodules%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[store 拆分成 modules 过程之前的项目一直是store下面放各种js文件（index.js、state.js、getter.js、mutation-types.js、mutations.js、action.js）;如下图 123456└── store ├── index.js # 我们组装模块并导出 store 的地方 ├── actions.js # 根级别的 action ├── mutations.js # 根级别的 mutation ├── state.js # 根级别的 state └── getter.js 使用单一的状态树，应用的所有状态都会集中在一个比较大的对象上面，随着项目需求的不断增加，状态树也会变得越来越臃肿，增加了状态树维护的复杂度,而且代码变得沉长；因此我们需要modules来为我们的状态树分隔成不同的模块，每个模块拥有自己的state，getters，mutations，actions；而且允许每个module里面嵌套子module；如下： 12345678└── store ├── index.js # 我们组装模块并导出 store 的地方 ├── actions.js # 根级别的 action ├── mutations.js # 根级别的 mutation ├── state.js # 根级别的 state └── modules ├── module1.js # 模块1的state树 └── module2.js # 模块2的state树 模块module1.js内部的代码结构如下12345678910111213141516171819202122232425262728import &#123; WIDTH_ADD &#125; from '@/store/mutation-types.js' // 引入事件类型export default &#123; namespaced: true, state: &#123; width: 100, height: 50 &#125;, getters: &#123; modulegGetWidth(state, getters, rootState) &#123; return state.width &#125;, modulegetHeight(state, getters, rootState) &#123; return state.height &#125; &#125;, mutations: &#123; [WIDTH_ADD](state) &#123; // 使用常量替代 Mutation 事件类型 return state.width++ &#125;, addHeight(state) &#123; // 不使用常量 return state.height++ &#125; &#125;, actions: &#123; &#125;&#125; 注册到根state。index.js如下123456789101112131415import state from './state'import getters from './getters'import mutations from './mutations'import actions from './actions'import module1 from './modules/module1.js' // 引入module1export default &#123; state, getters, mutations, actions, modules: &#123; module1 // 注册完成 &#125;&#125; 在组件内打印state。1console.log(this.$store.state) 如图由上图，可以看到，module1已经被我们添加到了当前的store.state内; 需要注意的 Vuex在组件中computed中使用的时候，计算属性不能和state的数据项同名（同名了也不会报错，就是获取不了数据了） 有一点值得注意的是：当我们在组件的计算属性中使用module里面的getters的时候,计算属性不和state的数据项同名这条规则貌似不生效，具体原因还不知道，如果有知道的大佬帮忙指点一下 默认情况下，没有设置命名空间的时候，模块内部的 action、mutation 和 getter 是(除了state)注册在全局命名空间的（如果有重名就会报错 [vuex] duplicate getter key: [method]）——这样使得多个模块能够对同一 mutation 或 action 作出响应。 解决方法是加命名空间 namespaced: true 如何在页面里面引用module 在modules内的每个模块加入命名空间 1namespaced: true vue文件内也可引入createNamespacedHelpers 12import &#123; createNamespacedHelpers &#125; from 'vuex'const &#123; mapState, mapActions &#125; = createNamespacedHelpers('mudole1') 注册到组件中12345678910111213import &#123; mapState, mapMutations &#125; from "vuex"computed: &#123; ...mapState('module1', &#123; width: state =&gt; state.width, // 关联, 此处的state 为 module1/state height: state =&gt; state.height &#125;) &#125;,methods: &#123; ...mapMutations('module1', &#123; // 命名空间module1 widthAdd: 'WIDTH_ADD', // 通过mutation-types.js addHeight: 'addHeight' // 直接加在mutations上面的方法 &#125;),&#125; 如何在模块中访问全局内容？ 如果你希望使用全局 state 和 getter，rootState 和 rootGetter 会作为第三和第四参数传入 getter，也会通过 context 对象的属性传入 action。 若需要在全局命名空间内分发 action 或提交 mutation，将 { root: true } 作为第三参数传给 dispatch 或 commit 即可。其实这块，作者在文档中已经说明的很清楚了，具体的链接：详细链接 划分模块的好处 state更为容易管理，尤其在团队人数多的时候，自己负责自己的state，既保证store了完整的状态树，又避免了相互之间的state冲突 不管是命名，或是操作 state 都会变得更加扁平和直观]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vuex</tag>
        <tag>state</tag>
      </tags>
  </entry>
</search>
